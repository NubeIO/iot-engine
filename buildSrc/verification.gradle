apply plugin: "java"
apply plugin: "jacoco"

def testFailures = []
def numProc = (Runtime.runtime.availableProcessors().intdiv(2) ?: 1).intValue()

jacoco {
    toolVersion = versions.tests.jacoco
}

task copyTestResult(type: Copy, group: "verification") {
    dependsOn test
    def tests = []
    subprojects.each {
        tests += it.testResultsDir
    }
    from tests
    include "**/*.xml"
    includeEmptyDirs = false
    into project.testResultsDir
}

task testReport(type: TestReport, group: "verification") {
    dependsOn copyTestResult
    destinationDir = file(project.testReportDir)
    reportOn subprojects.tasks.test
    doLast {
        if (!testFailures.isEmpty()) {
            def errors = testFailures.inject("There were failing tests. See the report at: " +
                                             destinationDir.toPath().resolve("index.html").toUri()) {
                acc, val -> acc + "\n" + "-" * 20 + "\n" + val
            }
            throw new TaskExecutionException(project.tasks.test, new Exception(errors))
        }
    }
}

test {
    if (project.hasProperty('excludeTests')) {
        exclude project.property('excludeTests')
    }
    ignoreFailures = true
    dependsOn subprojects.tasks.test
    finalizedBy testReport
    systemProperty 'vertx.logger-delegate-factory-class-name', 'io.vertx.core.logging.SLF4JLogDelegateFactory'
    subprojects {
        test {
            if (project.hasProperty('excludeTests')) {
                exclude project.property('excludeTests')
            }
            maxParallelForks = numProc
            ignoreFailures = true
            afterTest { descriptor, result ->
                if (descriptor.parent && result.getResultType() == TestResult.ResultType.FAILURE) {
                    testFailures += "$descriptor.parent.name > $descriptor.name $result.resultType\n\t$result.exception"
                }
            }
        }
    }
}

task jacocoMerge(type: JacocoMerge, group: "verification") {
    dependsOn(subprojects.tasks.test, subprojects.tasks.jacocoTestReport)
    mustRunAfter subprojects.tasks.jacocoTestReport
    destinationFile = file("${buildDir}/jacoco/test.exec")
    executionData = files(subprojects.tasks.jacocoTestReport.executionData).filter { f -> f.exists() }
}

jacocoTestReport {
    dependsOn jacocoMerge
    reports {
        xml.enabled = true
        html.enabled = true
    }
    additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories = files(subprojects.sourceSets.main.output)
}
